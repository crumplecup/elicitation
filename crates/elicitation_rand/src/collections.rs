//! Collection generators.
//!
//! Generators for standard collections like Vec, HashMap, HashSet.

use crate::Generator;
use rand::RngExt;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;

/// Generator for Vec with configurable length bounds.
///
/// Generates vectors with random length in [min_len, max_len) range,
/// where each element is generated by the inner generator.
#[derive(Debug)]
pub struct VecGenerator<G> {
    element_generator: G,
    min_len: usize,
    max_len: usize,
    seed: u64,
}

impl<G> VecGenerator<G> {
    /// Create a new vector generator with length bounds.
    ///
    /// # Arguments
    /// * `element_generator` - Generator for individual elements
    /// * `min_len` - Minimum vector length (inclusive)
    /// * `max_len` - Maximum vector length (exclusive)
    /// * `seed` - Seed for deterministic generation
    pub fn with_length(element_generator: G, min_len: usize, max_len: usize, seed: u64) -> Self {
        Self {
            element_generator,
            min_len,
            max_len,
            seed,
        }
    }

    /// Create a new vector generator with default length 0-10.
    pub fn new(element_generator: G, seed: u64) -> Self {
        Self::with_length(element_generator, 0, 10, seed)
    }

    /// Create a non-empty vector generator (length 1-10).
    pub fn non_empty(element_generator: G, seed: u64) -> Self {
        Self::with_length(element_generator, 1, 10, seed)
    }

    /// Create a fixed-length vector generator.
    pub fn fixed_length(element_generator: G, length: usize, seed: u64) -> Self {
        Self::with_length(element_generator, length, length + 1, seed)
    }
}

impl<G, T> Generator for VecGenerator<G>
where
    G: Generator<Target = T>,
{
    type Target = Vec<T>;

    fn generate(&self) -> Vec<T> {
        let mut rng = ChaCha8Rng::seed_from_u64(self.seed);
        let length = if self.min_len >= self.max_len {
            self.min_len
        } else {
            rng.random_range(self.min_len..self.max_len)
        };

        (0..length)
            .map(|_| self.element_generator.generate())
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::generators::RandomGenerator;

    #[test]
    fn test_vec_generator_default_length() {
        let inner = RandomGenerator::<u32>::with_seed(42);
        let generator = VecGenerator::new(inner, 123);

        for _ in 0..10 {
            let vec = generator.generate();
            assert!(vec.len() < 10, "Vec length should be < 10");
        }
    }

    #[test]
    fn test_vec_generator_custom_length() {
        let inner = RandomGenerator::<u32>::with_seed(42);
        let generator = VecGenerator::with_length(inner, 3, 6, 123);

        for _ in 0..10 {
            let vec = generator.generate();
            assert!(
                vec.len() >= 3 && vec.len() < 6,
                "Vec length {} not in [3, 6)",
                vec.len()
            );
        }
    }

    #[test]
    fn test_vec_generator_non_empty() {
        let inner = RandomGenerator::<u32>::with_seed(42);
        let generator = VecGenerator::non_empty(inner, 123);

        for _ in 0..10 {
            let vec = generator.generate();
            assert!(!vec.is_empty(), "Vec should not be empty");
            assert!(vec.len() < 10, "Vec length should be < 10");
        }
    }

    #[test]
    fn test_vec_generator_fixed_length() {
        let inner = RandomGenerator::<u32>::with_seed(42);
        let generator = VecGenerator::fixed_length(inner, 5, 123);

        for _ in 0..10 {
            let vec = generator.generate();
            assert_eq!(vec.len(), 5, "Vec should have exactly 5 elements");
        }
    }

    #[test]
    fn test_vec_generator_deterministic() {
        let seed = 42;
        let generator1 = VecGenerator::new(RandomGenerator::<u32>::with_seed(seed), seed);
        let generator2 = VecGenerator::new(RandomGenerator::<u32>::with_seed(seed), seed);

        // Same seed should produce same sequence
        for _ in 0..5 {
            let vec1 = generator1.generate();
            let vec2 = generator2.generate();
            assert_eq!(vec1, vec2, "Same seed should produce same vectors");
        }
    }

    #[test]
    fn test_vec_generator_empty_allowed() {
        let inner = RandomGenerator::<u32>::with_seed(42);
        let generator = VecGenerator::with_length(inner, 0, 5, 123);

        let mut found_empty = false;
        for _ in 0..50 {
            let vec = generator.generate();
            if vec.is_empty() {
                found_empty = true;
                break;
            }
        }

        // With range [0, 5), we should see empty vecs occasionally
        // This is a probabilistic test - if it never generates empty, that's a bug
        if !found_empty {
            eprintln!("Warning: No empty vecs generated in 100 attempts");
        }
    }
}
