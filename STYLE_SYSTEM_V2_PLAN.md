# Style System v2: Associated Types + Auto-Selection

**Version:** elicitation 0.3.0+
**Status:** Design - Revolutionary refinement
**Created:** 2026-01-19

## The Vision Refined

After implementing v1 (field-level `#[prompt(..., style = "name")]`), we discovered a fundamental issue: **how do primitives know which style to use?**

The solution: **Associated types + style enums + auto-selection**.

## Core Principles

1. **Silent defaults** - `u32::elicit(&client)` works with zero ceremony
2. **Optional overrides** - `client.with_style(ConfigStyle::Curt)` for explicit control
3. **Type-safe** - Each type has its own style enum (no stringly-typed registry)
4. **Self-describing** - The enum IS the available styles
5. **Leveraged** - Style enums derive `Elicit`, using Select pattern
6. **Composable** - Nested types have independent style contexts

## Architecture

### 1. Associated Type in Trait

```rust
pub trait Elicitation: Sized {
    /// The style enum for this type
    type Style: Elicitation + Default;
    
    /// Elicit with style context
    async fn elicit(client: &ElicitClient<'_>) -> Result<Self>;
}
```

### 2. Client Wrapper (Carries Style Context)

```rust
/// Client wrapper that carries style information
pub struct ElicitClient<'a> {
    peer: &'a Peer<RoleClient>,
    style_context: StyleContext<'a>,
}

impl<'a> ElicitClient<'a> {
    pub fn new(peer: &'a Peer<RoleClient>) -> Self {
        Self {
            peer,
            style_context: StyleContext::default(),
        }
    }
    
    /// Set style for a specific type
    pub fn with_style<T: Elicitation>(
        &self,
        style: T::Style,
    ) -> ElicitClient<'a> {
        let mut ctx = self.style_context.clone();
        ctx.set_style::<T>(style);
        ElicitClient {
            peer: self.peer,
            style_context: ctx,
        }
    }
    
    /// Get current style or auto-select from user
    pub async fn current_style<T: Elicitation>(&self) -> Result<T::Style> {
        if let Some(style) = self.style_context.get_style::<T>() {
            return Ok(style);
        }
        
        // No style set - ask user to select!
        T::Style::elicit(self).await
    }
    
    /// Get raw peer for MCP calls
    pub fn peer(&self) -> &Peer<RoleClient> {
        self.peer
    }
}

/// Storage for type-specific styles
#[derive(Clone, Default)]
struct StyleContext<'a> {
    styles: HashMap<TypeId, Box<dyn Any + 'a>>,
}
```

### 3. Macro-Generated Style Enums

For types with custom styles:

```rust
#[derive(Elicit)]
struct Config {
    #[prompt("Name", style = "curt")]
    #[prompt("Full name", style = "verbose")]
    name: String,
}
```

**Generates:**

```rust
/// Style variants for Config
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Elicit)]
#[prompt("Choose elicitation style:")]
enum ConfigStyle {
    Default,
    Curt,
    Verbose,
}

impl Default for ConfigStyle {
    fn default() -> Self {
        Self::Default
    }
}

impl Elicitation for Config {
    type Style = ConfigStyle;
    
    async fn elicit(client: &ElicitClient<'_>) -> Result<Self> {
        // Get or select style
        let style = client.current_style::<Self>().await?;
        
        // Build prompts based on style
        let name_prompt = match style {
            ConfigStyle::Curt => "Name",
            ConfigStyle::Verbose => "Full name",
            ConfigStyle::Default => "name",
        };
        
        // Inline elicit with styled prompt
        let params = elicitation::mcp::text_params(name_prompt);
        let result = client.peer().call_tool(...).await?;
        let name = elicitation::mcp::parse_string(result)?;
        
        Ok(Self { name })
    }
}
```

For primitives (no custom styles):

```rust
/// Default-only style for u32
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum U32Style {
    Default,
}

impl Default for U32Style {
    fn default() -> Self {
        Self::Default
    }
}

// Generated by macro for all std types
impl Elicitation for u32 {
    type Style = U32Style;
    
    async fn elicit(client: &ElicitClient<'_>) -> Result<Self> {
        // Primitives ignore style (for now)
        let prompt = "Enter number:";
        let params = elicitation::mcp::number_params(prompt, i64::MIN, i64::MAX);
        let result = client.peer().call_tool(...).await?;
        elicitation::mcp::parse_number(result)
    }
}

// Make the style enum itself Select-able (trivial since one option)
impl Elicitation for U32Style {
    type Style = U32Style; // Self-reference
    
    async fn elicit(_client: &ElicitClient<'_>) -> Result<Self> {
        Ok(Self::Default) // Always default
    }
}
```

## Usage Examples

### Silent Default

```rust
let client = ElicitClient::new(&peer);

// No style specified - uses default silently
let age: u32 = u32::elicit(&client).await?;
```

### Explicit Style Override

```rust
let client = ElicitClient::new(&peer);

// Set style for Config
let styled = client.with_style(ConfigStyle::Curt);
let config = Config::elicit(&styled).await?;
// ↑ All fields use Curt style
```

### Auto-Selection (No Style Set)

```rust
let client = ElicitClient::new(&peer);

// First call to Config - no style set
let config = Config::elicit(&client).await?;
// ↓ Automatically asks: "Choose elicitation style: Default, Curt, Verbose"
// ↓ Then proceeds with selected style
```

### Nested Styles (Independent Contexts)

```rust
#[derive(Elicit)]
struct Outer {
    #[prompt("Inner config:", style = "verbose")]
    inner: Config,  // Config has its own styles
}

let client = ElicitClient::new(&peer);

// Set style for Outer
let styled = client.with_style(OuterStyle::Verbose);

// Outer uses Verbose, but Config can have its own style
let outer = Outer::elicit(&styled).await?;
// ↓ Asks: "Choose style for Config: Default, Curt, Verbose"
```

### Builder Pattern (One-Off Override)

```rust
// For quick one-off style override
let config = Config::with_style(ConfigStyle::Curt)
    .elicit(&peer)
    .await?;
```

Implementation:

```rust
pub trait Elicitation: Sized {
    // ...existing methods...
    
    fn with_style(style: Self::Style) -> ElicitBuilder<Self> {
        ElicitBuilder { style }
    }
}

pub struct ElicitBuilder<T: Elicitation> {
    style: T::Style,
}

impl<T: Elicitation> ElicitBuilder<T> {
    pub async fn elicit(self, peer: &Peer<RoleClient>) -> Result<T> {
        let client = ElicitClient::new(peer).with_style::<T>(self.style);
        T::elicit(&client).await
    }
}
```

## Benefits

### 1. Type-Safe Styles
No string-based registry, no runtime lookups, all compile-time.

### 2. Zero Ceremony Default
```rust
let age = u32::elicit(&client).await?; // Just works
```

### 3. Self-Documenting
```rust
// What styles are available?
let _ = ConfigStyle::Default; // Compiler tells you!
```

### 4. Composable
Each type has its own style context. Nested types don't interfere.

### 5. Leverages Existing Patterns
Style enums derive `Elicit`, using Select pattern we already have.

### 6. Progressive Enhancement
- Start with no styles (single Default variant)
- Add `#[prompt(..., style = "name")]` later
- No breaking changes to API

## Implementation Phases

### Phase 1: Foundation (Breaking Changes) ✅ COMPLETE
- ✅ Add `ElicitClient` wrapper
- ✅ Add `type Style` associated type to trait
- ✅ Update all trait signatures: `elicit(client: &ElicitClient)`
- ✅ Implement `StyleContext` for type-erased storage
- ✅ Create macro to generate style enums
- ✅ Create `ElicitationStyle` trait for extensibility
- ✅ All 65+ standard types updated with Style enums
- ✅ All derive macros updated to generate Style enums
- ✅ All 12 examples updated to use ElicitClient

**Status:** Phase 1 complete! The foundation is solid. Users can now:
- Use default styles with zero ceremony
- Define custom styles for any type (including built-ins like i32)
- Chain multiple style overrides with `.with_style()`
- Extend the system by implementing `ElicitationStyle` trait

### Phase 2: Primitive Styles ✅ COMPLETE
- ✅ Generate single-variant style enums for all std types
- ✅ Update all primitive impls to use `ElicitClient`
- ✅ Primitives use default style (can enhance later)

All 14 primitives: bool, String, integers, floats, Duration, PathBuf, network types

### Phase 3: Derived Type Styles (NEXT)
- Update derive macro to generate multi-variant style enums
- Collect styles from `#[prompt(..., style = "name")]` attributes
- Generate match statements for prompt selection
- Implement inline elicitation with styled prompts

### Phase 4: Auto-Selection
- Implement `current_style_or_select()` logic
- Style enums automatically derive `Elicit` (Select pattern)
- Seamless user experience when no style set

### Phase 5: Builder Pattern
- Add `with_style()` method for one-off overrides
- Implement `ElicitBuilder` for ergonomics

## Migration from v1 (0.2.2)

**Breaking changes:**
- `elicit(client: &Peer<RoleClient>)` → `elicit(client: &ElicitClient)`
- All existing code needs wrapper: `ElicitClient::new(&peer)`

**Migration guide:**
```rust
// Old (0.2.2)
let age = u32::elicit(&peer).await?;

// New (0.3.0)
let client = ElicitClient::new(&peer);
let age = u32::elicit(&client).await?;
```

**Benefit:** Now supports style context, but works identically when no style set.

## Open Questions

1. **Style enum naming**: `ConfigStyle` vs `ConfigElicitStyle` vs `ConfigPromptStyle`?
   - **RESOLVED**: `ConfigStyle` is concise and clear
2. **Auto-select vs explicit**: Should missing style auto-ask, or return error?
   - **RESOLVED**: Fallback to `T::Style::default()` - silent defaults!
3. **Style inheritance**: Should child types inherit parent's style?
   - **RESOLVED**: No inheritance initially - each type independent
4. **Per-field overrides**: Can you override style for one field?
   ```rust
   let styled = client.with_style(ConfigStyle::Verbose);
   let name = String::with_style_override("curt").elicit(&styled).await?;
   ```
   - **FUTURE WORK**: Focus on type-level styles first
5. **Extensibility**: How can users define custom styles for built-in types?
   - **RESOLVED**: `ElicitationStyle` trait with blanket impl

## Decisions

### Auto-Select: NO (Fallback to Default Instead)
If no style set, use `T::Style::default()`. This maintains "silent default" and zero ceremony while allowing explicit overrides.

### ElicitationStyle Trait: YES
Created trait to make system fully extensible:
```rust
pub trait ElicitationStyle: Clone + Send + Sync + Default + 'static {}
impl<T> ElicitationStyle for T where T: Clone + Send + Sync + Default + 'static {}
```

This allows users to:
- Define custom style types for built-in types (e.g., `MyI32Style`)
- Use `.with_style::<i32, MyI32Style>(...)` to apply them
- Fallback to default when no custom style provided

### Style Enum Suffix: `Style`
`ConfigStyle` is concise and clear. Full name would be redundant.

### No Style Inheritance (Initially)
Each type manages its own style. Can add inheritance in v2 if needed.

### Per-Field Overrides: Future Work
Focus on type-level styles first. Field-level overrides can be added later.

## Success Criteria

- ✅ Primitives work with zero ceremony
- ✅ Custom styles are type-safe
- ✅ No string-based lookups
- ✅ Style selection leverages Select pattern
- ✅ Nested types have independent contexts
- ✅ Migration path is clear
- ✅ All existing tests pass with minimal changes
- ✅ Users can extend system with custom styles
- ✅ ElicitationStyle trait provides abstraction

## Timeline

- **Design**: ✅ Complete
- **Phase 1 (Foundation)**: ✅ Complete (2026-01-19)
- **Phase 2 (Primitives)**: ✅ Complete (2026-01-19)
- **Phase 3 (Derived Types)**: TODO - Next phase
- **Testing**: Ongoing
- **Documentation**: Ongoing
- **Release**: 0.3.0 (breaking changes from Phases 1-2 complete)

## Notes

This design emerged from implementing v1 and hitting the fundamental question: "How do primitives know which style to use?" The answer turned out to be elegant: **associated types + generated enums + auto-selection**.

The beauty is that style selection itself becomes just another elicitation, using the Select pattern we already have. No special cases, no magic - just composable traits all the way down.
